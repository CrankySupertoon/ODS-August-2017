# Fuck you Disyer. Stealing my fucking paypal. GET FUCKED: toontown.racing.DistributedRace
from panda3d.core import BitMask32, CardMaker, CollideMask, CollisionNode, CollisionSphere, CollisionTube, CompassEffect, Fog, Lens, Light, NodePath, Plane, Point3, TextNode, Texture, Vec3, Vec4
from direct.distributed.ClockDelta import *
from direct.distributed import DistributedObject
from direct.directnotify import DirectNotifyGlobal
from direct.gui.DirectLabel import *
from direct.gui.DirectButton import *
from direct.showbase import BulletinBoardWatcher
from direct.interval.IntervalGlobal import *
from otp.otpbase import OTPGlobals
from direct.interval.IntervalGlobal import *
from RaceGag import RaceGag
from toontown.toonbase import ToontownGlobals, TTLocalizer
from toontown.toon import ToonHeadFrame
from toontown.racing.KartDNA import InvalidEntry, getAccessory, getDefaultColor
from direct.distributed import DistributedSmoothNode
from math import fmod
from math import sqrt
from RaceGUI import RaceGUI
import RaceGlobals
from direct.task.Task import Task
from direct.fsm import ClassicFSM, State
from direct.fsm import State
from toontown.battle.BattleProps import *
from toontown.minigame import MinigameRulesPanel
from toontown.racing import Piejectile
from toontown.racing import EffectManager
from toontown.racing import PiejectileManager
from toontown.dna.DNAParser import *
from otp.ai.MagicWordGlobal import *
from toontown.safezone import SZUtil

class DistributedRace(DistributedObject.DistributedObject):
    notify = DirectNotifyGlobal.directNotify.newCategory('DistributedRace')
    ReadyPost = 'RaceReady'
    WinEvent = 'RaceWinEvent'
    BGM_BaseDir = 'phase_6/audio/bgm/'
    SFX_BaseDir = 'phase_6/audio/sfx/'
    SFX_StartBoop = SFX_BaseDir + 'KART_raceStart1.ogg'
    SFX_StartBoop2 = SFX_BaseDir + 'KART_raceStart2.ogg'
    SFX_Applause = SFX_BaseDir + 'KART_Applause_%d.ogg'

    def __init__(self, cr):
        if hasattr(base, 'race') and base.race:
            base.race.delete()
        self.qbox = loader.loadModel('phase_6/models/karting/qbox')
        self.boostArrowTexture = loader.loadTexture('phase_6/maps/boost_arrow.jpg', 'phase_6/maps/boost_arrow_a.rgb')
        self.boostArrowTexture.setMinfilter(Texture.FTLinear)
        DistributedObject.DistributedObject.__init__(self, cr)
        self.kartMap = {}
        self.fsm = ClassicFSM.ClassicFSM('Race', [State.State('join', self.enterJoin, self.exitJoin, ['prep', 'leave']),
         State.State('prep', self.enterPrep, self.exitPrep, ['tutorial', 'leave']),
         State.State('tutorial', self.enterTutorial, self.exitTutorial, ['start', 'waiting', 'leave']),
         State.State('waiting', self.enterWaiting, self.exitWaiting, ['start', 'leave']),
         State.State('start', self.enterStart, self.exitStart, ['racing', 'leave']),
         State.State('racing', self.enterRacing, self.exitRacing, ['finished', 'leave']),
         State.State('finished', self.enterFinished, self.exitFinished, ['leave']),
         State.State('leave', self.enterLeave, self.exitLeave, [])], 'join', 'leave')
        self.gui = RaceGUI(self)
        base.race = self
        self.currT = 0
        self.currLapT = 0
        self.currGag = 0
        self.tdelay = 0
        self.finished = False
        self.thrownGags = []
        self.effectManager = EffectManager.EffectManager()
        self.piejectileManager = PiejectileManager.PiejectileManager()
        self.lastTimeUpdate = globalClock.getFrameTime()
        self.initGags()
        self.canShoot = True
        self.isUrbanTrack = False
        self.hasFog = False
        self.dummyNode = None
        self.fog = None
        self.bananaSound = loader.loadSfx('phase_6/audio/sfx/KART_tossBanana.ogg')
        self.anvilFall = loader.loadSfx('phase_6/audio/sfx/KART_Gag_Hit_Anvil.ogg')
        self.accept('leaveRace', self.leaveRace)
        self.accept('finishRace', self.finishRace)
        self.toonsToLink = []
        self.curveTs = []
        self.curvePoints = []
        self.localKart = None
        self.musicTrack = None
        self.victory = None
        self.miscTaskNames = []
        self.boostDir = {}
        self.knownPlace = {}
        self.curve = None
        self.barricadeSegments = 100.0
        self.outerBarricadeDict = {}
        self.innerBarricadeDict = {}
        self.maxLap = 0
        self.oldT = 0
        self.debugIt = 0
        self.startPos = None
        return

    def generate(self):
        self.notify.debug('generate: %s' % self.doId)
        DistributedObject.DistributedObject.generate(self)
        bboard.post('race', self)
        self.roomWatcher = None
        self.cutoff = 0.01
        self.startBoopSfx = loader.loadSfx(self.SFX_StartBoop)
        self.startBoop2Sfx = loader.loadSfx(self.SFX_StartBoop2)
        return

    def announceGenerate(self):
        self.notify.debug('announceGenerate: %s' % self.doId)
        DistributedObject.DistributedObject.announceGenerate(self)
        musicFile = self.BGM_BaseDir + RaceGlobals.TrackDict[self.trackId][7]
        self.raceMusic = loader.loadMusic(musicFile)
        base.playMusic(self.raceMusic, looping=1, volume=0.8)
        camera.reparentTo(render)
        if self.trackId in (RaceGlobals.RT_Urban_1,
         RaceGlobals.RT_Urban_1_rev,
         RaceGlobals.RT_Urban_2,
         RaceGlobals.RT_Urban_2_rev):
            self.isUrbanTrack = True
        self.oldFarPlane = base.camLens.getFar()
        base.camLens.setFar(12000)
        localAvatar.startPosHprBroadcast()
        localAvatar.d_broadcastPositionNow()
        DistributedSmoothNode.activateSmoothing(1, 1)
        self.reversed = self.trackId / 2.0 > int(self.trackId / 2.0)
        self.sky = loader.loadModel('phase_3.5/models/props/TT_sky')
        self.sky.setPos(0, 0, 0)
        self.sky.setScale(20.0)
        self.sky.setFogOff()
        if self.trackId in (RaceGlobals.RT_Urban_1,
         RaceGlobals.RT_Urban_1_rev,
         RaceGlobals.RT_Urban_2,
         RaceGlobals.RT_Urban_2_rev):
            self.loadFog()
        self.setupGeom()
        self.startSky()

    def disable(self):
        self.notify.debug('disable %s' % self.doId)
        if self.musicTrack:
            self.musicTrack.finish()
        self.raceMusic.stop()
        self.stopSky()
        if self.sky is not None:
            self.sky.removeNode()
        if self.dummyNode:
            self.dummyNode.removeNode()
            self.dummyNode = None
        for taskName in self.miscTaskNames:
            taskMgr.remove(taskName)

        taskMgr.remove('raceWatcher')
        self.ignoreAll()
        DistributedSmoothNode.activateSmoothing(1, 0)
        if self.isUrbanTrack:
            self.unloadUrbanTrack()
        if self.fog:
            render.setFogOff()
            del self.fog
            self.fog = None
        if self.geom is not None:
            self.geom.hide()
        base.camLens.setFar(self.oldFarPlane)
        DistributedObject.DistributedObject.disable(self)
        return

    def delete(self):
        self.notify.debug('delete %s' % self.doId)
        if self.gui:
            self.gui.destroy()
            self.gui = None
        if self.geom is not None:
            self.geom.removeNode()
            self.geom = None
            for i in self.gags:
                i.delete()
                del i

        self.piejectileManager.delete()
        if not hasattr(base, 'race') or not hasattr(self, 'curveTs'):
            return
        else:
            if self.curveTs:
                del self.curveTs
            if self.curvePoints:
                del self.curvePoints
            if self.curve:
                del self.curve
            if self.victory:
                del self.victory
            del self.fsm
            del self.anvilFall
            del self.bananaSound
            del self.localKart
            taskMgr.remove(self.uniqueName('countdownTimerTask'))
            taskMgr.remove('raceWatcher')
            bboard.remove('race')
            self.ignoreAll()
            DistributedObject.DistributedObject.delete(self)
            del base.race
            return

    def d_requestThrow(self, x, y, z):
        self.sendUpdate('requestThrow', [x, y, z])

    def d_requestKart(self):
        self.sendUpdate('requestKart', [])

    def waitingForJoin(self):
        self.notify.debug('I got the barrier')
        self.fsm.enterInitialState()

    def racerDisconnected(self, avId):
        self.notify.debug('lost racer: %s' % avId)
        if avId in self.kartMap:
            if avId in self.toonsToLink:
                self.toonsToLink.remove(avId)
            toon = base.cr.doId2do.get(avId, None)
            kart = base.cr.doId2do.get(self.kartMap.get(avId, None), None)
            self.avIds.remove(avId)
            del self.kartMap[avId]
            self.gui.racerLeft(avId, unexpected=True)
            if kart:
                kart.reparentTo(hidden)
            if toon:
                toon.reparentTo(hidden)
            if len(self.toonsToLink) == 0:
                self.doneBarrier('waitingForPrep')
        return

    def setPlace(self, avId, totalTime, place, entryFee, qualify, winnings, bonus, trophies, circuitPoints, circuitTime):
        if self.fsm.getCurrentState().getName() == 'leaving':
            return
        else:
            if avId == localAvatar.doId:
                cheerToPlay = place + (4 - self.numRacers)
                if cheerToPlay > 4:
                    cheerToPlay = 4
                self.victory = loader.loadSfx(self.SFX_Applause % cheerToPlay)
                self.victory.play()
            self.knownPlace[avId] = place
            kart = base.cr.doId2do.get(self.kartMap.get(avId, None), None)
            avatar = base.cr.doId2do.get(avId, None)
            if avatar:
                self.gui.racerFinished(avId, self.trackId, place, totalTime, entryFee, qualify, winnings, bonus, trophies, circuitPoints, circuitTime)
                taskName = 'hideAv: %s' % avId
                taskMgr.doMethodLater(6, avatar.reparentTo, taskName, extraArgs=[hidden])
                self.miscTaskNames.append(taskName)
            if kart:
                taskName = 'hideKart: %s' % self.localKart.doId
                taskMgr.doMethodLater(6, kart.reparentTo, taskName, extraArgs=[hidden])
                self.miscTaskNames.append(taskName)
            return

    def setCircuitPlace(self, avId, entryFee, winnings, bonus, trophies):
        if self.fsm.getCurrentState().getName() == 'leaving':
            return
        else:
            if avId == localAvatar.doId:
                cheerToPlay = place + (4 - self.numRacers)
                self.victory = loader.loadSfx(self.SFX_Applause % cheerToPlay)
                self.victory.play()
            avatar = base.cr.doId2do.get(avId, None)
            if avatar:
                self.gui.racerFinishedCircuit(avId, self.knownPlace.get(avId, 0), entryFee, winnings, bonus, trophies)
            return

    def endCircuitRace(self, avIds):
        placeFixup = []
        for i, avId in enumerate(avIds):
            if avId in self.knownPlace:
                placeFixup.append([self.knownPlace[avId] - 1, i])

        self.gui.circuitFinished(placeFixup)

    def prepForRace(self):
        self.fsm.request('prep')

    def startRace(self, startTime = 0):
        self.baseTime = globalClockDelta.networkToLocalTime(startTime)
        self.fsm.request('start')

    def startTutorial(self):
        self.fsm.request('tutorial')

    def genGag(self, slot, number, type):
        self.notify.debug('making gag...')
        if not self.gags[slot].isActive():
            self.gags[slot].genGag(number, type)

    def dropAnvilOn(self, ownerId, avId, timeStamp):
        kart = base.cr.doId2do.get(self.kartMap.get(avId, None), None)
        if kart:
            if avId != ownerId:
                if avId == localAvatar.doId:
                    self.anvilFall.play()
                    kart.dropOnMe(timeStamp)
                else:
                    kart.dropOnHim(timeStamp)
        return

    def shootPiejectile(self, sourceId, targetId, type = 0):
        kart = base.cr.doId2do.get(self.kartMap.get(sourceId, None), None)
        if kart:
            self.piejectileManager.addPiejectile(sourceId, targetId, type)
        return

    def goToSpeedway(self, avIds, reason = RaceGlobals.Exit_UserReq):
        self.notify.debug('goToSpeedway %s %s' % (avIds, reason))
        if localAvatar.doId in avIds:
            base.loader.endBulkLoad('atRace')
            self.kartCleanup()
            self.doneBarrier('waitingForExit')
            self.sendUpdate('racerLeft', [localAvatar.doId])
            out = {'loader': 'safeZoneLoader',
             'where': 'playground',
             'how': 'teleportIn',
             'hoodId': localAvatar.lastHood,
             'zoneId': localAvatar.lastHood,
             'shardId': None,
             'avId': -1,
             'reason': reason}
            base.cr.playGame.fsm.request('quietZone', [out])
        return

    def kartCleanup(self):
        kart = self.localKart
        if kart:
            kart.setState('P', 0)
            for i in self.avIds:
                if i != localAvatar.doId:
                    toon = base.cr.doId2do.get(i, None)
                    if toon:
                        toon.stopSmooth()
                        toon.setScale(1)
                        toon.setShear(0, 0, 0)
                        toon.reparentTo(render)
                        toon.doHeadScale(None)

        localAvatar.setPos(0, 14, 0)
        localAvatar.sendCurrentPosition()
        return

    def heresMyT(self, avId, avNumLaps, avTime, timestamp):
        self.gui.updateRacerInfo(avId, curvetime=avNumLaps + avTime)

    def setZoneId(self, zoneId):
        self.zoneId = zoneId

    def setRaceType(self, raceType):
        self.raceType = raceType

    def setCircuitLoop(self, circuitLoop):
        self.circuitLoop = circuitLoop

    def setTrackId(self, id):
        DistributedRace.notify.debug('setTrackId: %s' % id)
        self.trackId = id

    def setAvatars(self, avIds):
        ids = ''
        for i in avIds:
            ids += str(i) + ' '

        DistributedRace.notify.debug('setAvatars: %s' % ids)
        self.avIds = avIds
        self.avT = [0] * len(self.avIds)

    def setLapCount(self, lapCount):
        self.lapCount = lapCount

    def setStartingPlaces(self, startList):
        self.startingPlaces = startList

    def enterJoin(self):
        self.doneBarrier('waitingForJoin')
        self.notify.debug('entering Join')

    def exitJoin(self):
        pass

    def setEnteredRacers(self, avAndKarts):
        self.notify.debug('setEnteredRacers %s' % avAndKarts)
        avatarsGone = []
        avatarsLeft = []
        self.numRacers = len(avAndKarts)
        for i in avAndKarts:
            if i[0] in self.avIds:
                self.kartMap[i[0]] = i[1]
                avatarsLeft.append(i[0])

        for i in self.avIds:
            if i not in avatarsLeft:
                avatarsGone.append(i)

        for i in avatarsGone:
            self.avIds.remove(i)

        self.toonsToLink = list(self.avIds)
        for i in avAndKarts:
            self.cr.relatedObjectMgr.requestObjects(i, allCallback=self.__gotKartAvatarLink)

    def __gotKartAvatarLink(self, avAndKart):
        self.notify.debug('got a Link')
        toon = avAndKart[0]
        kart = avAndKart[1]
        if toon.doId in self.toonsToLink:
            self.toonsToLink.remove(toon.doId)
        if toon.doId == localAvatar.doId:
            self.localKart = kart
        if len(self.toonsToLink) == 0:
            self.doneBarrier('waitingForPrep')

    def enterPrep(self):
        self.d_requestKart()
        self.notify.debug('entering Prep State')
        if self.reversed:
            self.spin = Vec3(180, 0, 0)
        else:
            self.spin = Vec3(0, 0, 0)
        self.gui.initRaceMode()
        self.gui.initResultMode()
        self.myPos = self.startingPos[self.startingPlaces[self.avIds.index(localAvatar.doId)]]
        self.localKart.setPosHpr(self.myPos[0], self.myPos[1] + self.spin)
        self.localKart.setupLapCollisions()
        if self.dummyNode:
            self.dummyNode.setPosHpr(self.myPos[0], self.myPos[1] + self.spin)
        self.currentPole = self.findSegmentStart()
        self.rabbitPoint = Vec3(0, 0, 0)
        self.doneBarrier('waitingForReady')

    def exitPrep(self):
        pass

    def enterTutorial(self):
        self.notify.debug('entering Tutorial State')
        base.loader.endBulkLoad('atRace')
        self.localKart.setPosHpr(self.myPos[0], self.myPos[1] + self.spin)
        base.transitions.irisIn()
        self.rulesDoneEvent = 'finishedRules'
        self.accept(self.rulesDoneEvent, self.handleRulesDone)
        self.rulesPanel = MinigameRulesPanel.MinigameRulesPanel('RacingRulesPanel', self.getTitle(), self.getInstructions(), self.rulesDoneEvent, 10)
        self.rulesPanel.load()
        self.rulesPanel.frame.setPos(0, 0, -0.6667)
        self.rulesPanel.enter()

    def exitTutorial(self):
        self.ignore(self.rulesDoneEvent)
        self.rulesPanel.exit()
        self.rulesPanel.unload()
        del self.rulesPanel

    def getTitle(self):
        return TTLocalizer.KartRace_TitleInfo

    def getInstructions(self):
        return TTLocalizer.KartRace_TrackInfo[self.trackId]

    def handleRulesDone(self):
        self.doneBarrier('readRules')
        self.fsm.request('waiting')

    def enterWaiting(self):
        self.waitingLabel = DirectLabel()
        self.waitingLabel['text'] = TTLocalizer.WaitingForOtherToons
        self.waitingLabel.setScale(TTLocalizer.DRenterWaiting)

    def exitWaiting(self):
        self.waitingLabel.removeNode()

    def enterStart(self):
        waitTime = self.baseTime - globalClock.getFrameTime()
        taskName = 'enableRaceModeLater'
        taskMgr.doMethodLater(1, self.gui.enableRaceMode, taskName, extraArgs=[])
        self.miscTaskNames.append(taskName)
        for i in self.avIds:
            self.gui.racerEntered(i)

        self.startCountdownClock(waitTime, 0)
        taskMgr.doMethodLater(waitTime, self.fsm.request, 'goToRacing', extraArgs=['racing'])

    def exitStart(self):
        pass

    def enterRacing(self):
        self.localKart.setInput(1)
        self.gui.setTimerEnabled(True)
        self.raceTask = taskMgr.add(self.raceWatcher, 'raceWatcher')

    def exitRacing(self):
        pass

    def raceWatcher(self, task):
        kart = base.cr.doId2do.get(self.kartMap.get(localAvatar.doId, None), None)
        if self.localKart.amIClampingPosition():
            self.notify.debug('teleporting kart %d back to main track' % localAvatar.doId)
            self.localKart.setPos(self.curvePoints[self.currentPole])
        kartPoint = self.localKart.getPos()
        direction = 0
        while True:
            currPoint = self.curvePoints[self.currentPole]
            nextPole = (self.currentPole + 1) % len(self.curvePoints)
            nextPoint = self.curvePoints[nextPole]
            segment = nextPoint - currPoint
            segment.setZ(0)
            segLength2 = segment.lengthSquared()
            kartVector = kartPoint - currPoint
            kartVector.setZ(0)
            project = segment * (segment.dot(kartVector) / segLength2)
            projLength2 = project.lengthSquared()
            if project.dot(segment) < 0:
                if direction == 1:
                    break
                prevPole = (self.currentPole - 1) % len(self.curvePoints)
                self.currentPole = prevPole
                direction = -1
            elif projLength2 > segLength2:
                if direction == -1:
                    break
                self.currentPole = nextPole
                direction = 1
            else:
                break

        if self.dummyNode:
            self.dummyNode.setPos(kartPoint[0], kartPoint[1], 0)
            self.dummyNode.setHpr(self.localKart.getH(), 0, 0)
        t = projLength2 / segLength2
        if self.debugIt:
            self.notify.debug('self.debugIt = %d' % self.debugIt)
        if nextPole < self.currentPole:
            newT = self.curveTs[self.currentPole] * (1 - t) + self.curve.getMaxT() * t
        else:
            newT = self.curveTs[self.currentPole] * (1 - t) + self.curveTs[nextPole] * t
        kartDirection = self.localKart.forward.getPos(render) - self.localKart.getPos(render)
        kartDirection.normalize()
        project.normalize()
        globalDirection = kartDirection.dot(project)
        if globalDirection < 0:
            self.wrongWay = True
        elif globalDirection > 0.1:
            self.wrongWay = False
        newLapT = (newT - self.startT) / self.curve.getMaxT() % 1.0
        if newLapT - self.currLapT < -0.5:
            self.laps += 1
            self.changeMusicTempo(1 + self.laps * 0.5)
            self.notify.debug('crossed the start line: %s, %s, %s, %s' % (self.laps,
             self.startT,
             self.currT,
             newT))
        elif newLapT - self.currLapT > 0.5:
            self.laps -= 1
            self.changeMusicTempo(1 + self.laps * 0.5)
            self.notify.debug('crossed the start line - wrong way: %s, %s, %s, %s' % (self.laps,
             self.startT,
             self.currT,
             newT))
        self.currT = newT
        self.currLapT = newLapT
        if self.isUrbanTrack:
            self.showBuildings(self.currT)
        now = globalClock.getFrameTime()
        timestamp = globalClockDelta.localToNetworkTime(now)
        if self.laps == self.lapCount:
            self.finishRace()
        if self.laps > self.maxLap:
            self.maxLap = self.laps
            self.sendUpdate('heresMyT', [localAvatar.doId,
             self.laps,
             self.currLapT,
             timestamp])
        if now - self.lastTimeUpdate > 0.5:
            self.lastTimeUpdate = now
            self.sendUpdate('heresMyT', [localAvatar.doId,
             self.laps,
             self.currLapT,
             timestamp])
        self.gui.updateRacerInfo(localAvatar.doId, curvetime=self.currLapT + self.laps)
        self.gui.update(now)
        return Task.cont

    def enterFinished(self):
        taskMgr.remove('raceWatcher')
        self.fadeOutMusic()
        self.localKart.interruptTurbo()
        self.localKart.disableControls()
        taskName = 'parkIt'
        taskMgr.doMethodLater(2, self.stopDriving, taskName, extraArgs=[])
        self.miscTaskNames.append(taskName)
        self.finished = True
        camera.reparentTo(render)
        camera.setPos(self.localKart.getPos(render) + Vec3(0, 0, 10))
        camera.setH(self.localKart.getH(render) + 180)
        self.gui.disableRaceMode()
        self.gui.enableResultMode()
        localAvatar.reparentTo(hidden)
        self.localKart.reparentTo(hidden)

    def exitFinished(self):
        pass

    def stopDriving(self):
        kart = base.cr.doId2do.get(self.kartMap.get(localAvatar.doId, None), None)
        cpos = camera.getPos()
        chpr = camera.getHpr()
        localAvatar.reparentTo(hidden)
        self.localKart.reparentTo(hidden)
        self.localKart.stopSmooth()
        self.localKart.stopPosHprBroadcast()
        camera.setPos(cpos)
        camera.setHpr(chpr)
        return

    def enterLeave(self):
        kart = base.cr.doId2do.get(self.kartMap.get(localAvatar.doId, None), None)
        taskMgr.remove('raceWatcher')
        self.gui.disable()
        if self.localKart:
            self.localKart.disableControls()
        base.transitions.irisOut()
        if self.raceType == RaceGlobals.Circuit and not len(self.circuitLoop) == 0:
            self.sendUpdate('racerLeft', [localAvatar.doId])
        else:
            taskMgr.doMethodLater(1, self.goToSpeedway, 'leaveRace', extraArgs=[[localAvatar.doId], RaceGlobals.Exit_UserReq])
        if self.victory:
            self.victory.stop()
        self.bananaSound.stop()
        self.anvilFall.stop()
        return

    def exitLeave(self):
        pass

    def getCountdownColor(self, countdownTimeInt):
        clockNodeColors = [Vec4(0, 1, 0, 1),
         Vec4(1, 1, 0, 1),
         Vec4(1, 0.5, 0, 1),
         Vec4(1, 0, 0, 1)]
        i = max(min(countdownTimeInt, len(clockNodeColors) - 1), 0)
        return clockNodeColors[i]

    def startCountdownClock(self, countdownTime, ts):
        self.clockNode = TextNode('k')
        self.clockNode.setFont(ToontownGlobals.getSignFont())
        self.clockNode.setAlign(TextNode.ACenter)
        countdownInt = int(countdownTime)
        self.clockNode.setTextColor(self.getCountdownColor(countdownInt))
        self.clockNode.setText(str(countdownInt))
        self.clock = render2d.attachNewNode(self.clockNode)
        rs = TTLocalizer.DRrollScale
        self.clock.setPosHprScale(0, 0, 0, 0, 0, 0, rs, rs, rs)
        self.clock.hide()
        if ts < countdownTime:
            self.countdown(countdownTime - ts)

    def timerTask(self, task):
        countdownTime = int(task.duration - task.time)
        timeStr = str(countdownTime + 1)
        if self.clock.isHidden():
            if task.duration - task.time <= task.maxCount:
                self.clock.show()
        if self.clockNode.getText() != timeStr:
            self.startBoopSfx.play()
            self.clockNode.setText(timeStr)
            self.clockNode.setTextColor(self.getCountdownColor(countdownTime + 1))
        if task.time >= task.duration:
            self.startBoop2Sfx.play()
            self.clockNode.setText(TTLocalizer.KartRace_Go)
            self.clockNode.setTextColor(self.getCountdownColor(-1))
            taskMgr.doMethodLater(1, self.endGoSign, 'removeGoSign')
            return Task.done
        else:
            return Task.cont

    def endGoSign(self, t):
        self.clock.removeNode()

    def countdown(self, duration):
        countdownTask = Task(self.timerTask)
        countdownTask.duration = duration
        countdownTask.maxCount = RaceGlobals.RaceCountdown
        taskMgr.remove(self.uniqueName('countdownTimerTask'))
        return taskMgr.add(countdownTask, self.uniqueName('countdownTimerTask'))

    def initGags(self):
        self.banana = globalPropPool.getProp('banana')
        self.banana.setScale(2)
        self.pie = globalPropPool.getProp('creampie')
        self.pie.setScale(1)

    def makeCheckPoint(self, trigger, location, event):
        cs = CollisionSphere(0, 0, 0, 140)
        cs.setTangible(0)
        triggerEvent = 'imIn-' + trigger
        cn = CollisionNode(trigger)
        cn.addSolid(cs)
        cn.setIntoCollideMask(BitMask32(32768))
        cn.setFromCollideMask(BitMask32(32768))
        cnp = NodePath(cn)
        cnp.reparentTo(self.geom)
        cnp.setPos(location)
        self.accept(triggerEvent, event)

    def loadUrbanTrack--- This code section failed: ---

0	LOAD_GLOBAL       'DNAStorage'
3	CALL_FUNCTION_0   None
6	LOAD_FAST         'self'
9	STORE_ATTR        'dnaStore'

12	LOAD_CONST        'phase_6/dna/urban_track_town.bdna'
15	STORE_FAST        'dnaFile'

18	LOAD_FAST         'self'
21	LOAD_ATTR         'trackId'
24	LOAD_GLOBAL       'RaceGlobals'
27	LOAD_ATTR         'RT_Urban_2'
30	LOAD_GLOBAL       'RaceGlobals'
33	LOAD_ATTR         'RT_Urban_2_rev'
36	BUILD_TUPLE_2     None
39	COMPARE_OP        'in'
42	POP_JUMP_IF_FALSE '54'

45	LOAD_CONST        'phase_6/dna/urban_track_town_B.bdna'
48	STORE_FAST        'dnaFile'
51	JUMP_FORWARD      '54'
54_0	COME_FROM         '51'

54	LOAD_GLOBAL       'loader'
57	LOAD_ATTR         'loadDNAFile'
60	LOAD_FAST         'self'
63	LOAD_ATTR         'dnaStore'
66	LOAD_FAST         'dnaFile'
69	CALL_FUNCTION_2   None
72	UNPACK_SEQUENCE_2 None
75	STORE_FAST        'prop'
78	LOAD_FAST         'self'
81	STORE_ATTR        'townGeom'

84	LOAD_FAST         'self'
87	LOAD_ATTR         'townGeom'
90	LOAD_ATTR         'reparentTo'
93	LOAD_FAST         'self'
96	LOAD_ATTR         'geom'
99	CALL_FUNCTION_1   None
102	POP_TOP           None

103	LOAD_FAST         'self'
106	LOAD_ATTR         'townGeom'
109	LOAD_ATTR         'findAllMatches'
112	LOAD_CONST        '**/+CollisionNode'
115	CALL_FUNCTION_1   None
118	LOAD_ATTR         'stash'
121	CALL_FUNCTION_0   None
124	POP_TOP           None

125	BUILD_MAP         None
128	LOAD_FAST         'self'
131	STORE_ATTR        'buildingGroups'

134	BUILD_MAP         None
137	LOAD_FAST         'self'
140	STORE_ATTR        'currBldgInd'

143	BUILD_MAP         None
146	LOAD_FAST         'self'
149	STORE_ATTR        'currBldgGroups'

152	LOAD_FAST         'self'
155	LOAD_ATTR         'geom'
158	LOAD_ATTR         'find'
161	LOAD_CONST        '**/polySurface8'
164	CALL_FUNCTION_1   None
167	STORE_FAST        'bgGeom'

170	LOAD_FAST         'self'
173	LOAD_ATTR         'dummyNode'
176	POP_JUMP_IF_FALSE '198'

179	LOAD_FAST         'bgGeom'
182	LOAD_ATTR         'reparentTo'
185	LOAD_FAST         'self'
188	LOAD_ATTR         'dummyNode'
191	CALL_FUNCTION_1   None
194	POP_TOP           None
195	JUMP_FORWARD      '211'

198	LOAD_FAST         'bgGeom'
201	LOAD_ATTR         'reparentTo'
204	LOAD_GLOBAL       'localAvatar'
207	CALL_FUNCTION_1   None
210	POP_TOP           None
211_0	COME_FROM         '195'

211	LOAD_FAST         'bgGeom'
214	LOAD_ATTR         'setScale'
217	LOAD_CONST        0.1
220	CALL_FUNCTION_1   None
223	POP_TOP           None

224	LOAD_GLOBAL       'CompassEffect'
227	LOAD_ATTR         'make'
230	LOAD_GLOBAL       'NodePath'
233	CALL_FUNCTION_0   None
236	LOAD_GLOBAL       'CompassEffect'
239	LOAD_ATTR         'PRot'
242	CALL_FUNCTION_2   None
245	STORE_FAST        'ce'

248	LOAD_FAST         'bgGeom'
251	LOAD_ATTR         'node'
254	CALL_FUNCTION_0   None
257	LOAD_ATTR         'setEffect'
260	LOAD_FAST         'ce'
263	CALL_FUNCTION_1   None
266	POP_TOP           None

267	LOAD_FAST         'bgGeom'
270	LOAD_ATTR         'setDepthTest'
273	LOAD_CONST        0
276	CALL_FUNCTION_1   None
279	POP_TOP           None

280	LOAD_FAST         'bgGeom'
283	LOAD_ATTR         'setDepthWrite'
286	LOAD_CONST        0
289	CALL_FUNCTION_1   None
292	POP_TOP           None

293	LOAD_FAST         'bgGeom'
296	LOAD_ATTR         'setBin'
299	LOAD_CONST        'background'
302	LOAD_CONST        102
305	CALL_FUNCTION_2   None
308	POP_TOP           None

309	LOAD_FAST         'bgGeom'
312	LOAD_ATTR         'setZ'
315	LOAD_CONST        -1
318	CALL_FUNCTION_1   None
321	POP_TOP           None

322	LOAD_FAST         'bgGeom'
325	LOAD_FAST         'self'
328	STORE_ATTR        'bgGeom'

331	LOAD_FAST         'self'
334	LOAD_ATTR         'geom'
337	LOAD_ATTR         'findAllMatches'
340	LOAD_CONST        '**/+ModelNode'
343	CALL_FUNCTION_1   None
346	STORE_FAST        'l'

349	SETUP_LOOP        '385'
352	LOAD_FAST         'l'
355	GET_ITER          None
356	FOR_ITER          '384'
359	STORE_FAST        'n'

362	LOAD_FAST         'n'
365	LOAD_ATTR         'node'
368	CALL_FUNCTION_0   None
371	LOAD_ATTR         'setPreserveTransform'
374	LOAD_CONST        0
377	CALL_FUNCTION_1   None
380	POP_TOP           None
381	JUMP_BACK         '356'
384	POP_BLOCK         None
385_0	COME_FROM         '349'

385	LOAD_FAST         'self'
388	LOAD_ATTR         'geom'
391	LOAD_ATTR         'flattenLight'
394	CALL_FUNCTION_0   None
397	POP_TOP           None

398	LOAD_CONST        0
401	STORE_FAST        'maxNum'

404	SETUP_LOOP        '710'
407	LOAD_CONST        'inner'
410	LOAD_CONST        'outer'
413	BUILD_LIST_2      None
416	GET_ITER          None
417	FOR_ITER          '709'
420	STORE_FAST        'side'

423	BUILD_LIST_0      None
426	LOAD_FAST         'self'
429	LOAD_ATTR         'buildingGroups'
432	LOAD_FAST         'side'
435	STORE_SUBSCR      None

436	LOAD_CONST        None
439	LOAD_FAST         'self'
442	LOAD_ATTR         'currBldgInd'
445	LOAD_FAST         'side'
448	STORE_SUBSCR      None

449	LOAD_CONST        None
452	LOAD_FAST         'self'
455	LOAD_ATTR         'currBldgGroups'
458	LOAD_FAST         'side'
461	STORE_SUBSCR      None

462	LOAD_CONST        0
465	STORE_FAST        'i'

468	SETUP_LOOP        '685'

471	LOAD_FAST         'self'
474	LOAD_ATTR         'townGeom'
477	LOAD_ATTR         'find'
480	LOAD_CONST        '**/Buildings_'
483	LOAD_FAST         'side'
486	BINARY_ADD        None
487	LOAD_CONST        '-'
490	BINARY_ADD        None
491	LOAD_GLOBAL       'str'
494	LOAD_FAST         'i'
497	CALL_FUNCTION_1   None
500	BINARY_ADD        None
501	CALL_FUNCTION_1   None
504	STORE_FAST        'bldgGroup'

507	LOAD_FAST         'bldgGroup'
510	LOAD_ATTR         'isEmpty'
513	CALL_FUNCTION_0   None
516	POP_JUMP_IF_FALSE '523'

519	BREAK_LOOP        None
520	JUMP_FORWARD      '523'
523_0	COME_FROM         '520'

523	LOAD_FAST         'bldgGroup'
526	LOAD_ATTR         'findAllMatches'
529	LOAD_CONST        '**/+ModelNode'
532	CALL_FUNCTION_1   None
535	STORE_FAST        'l'

538	SETUP_LOOP        '611'
541	LOAD_FAST         'l'
544	GET_ITER          None
545	FOR_ITER          '610'
548	STORE_FAST        'n'

551	LOAD_FAST         'n'
554	LOAD_ATTR         'getParent'
557	CALL_FUNCTION_0   None
560	LOAD_ATTR         'attachNewNode'
563	LOAD_FAST         'n'
566	LOAD_ATTR         'getName'
569	CALL_FUNCTION_0   None
572	CALL_FUNCTION_1   None
575	STORE_FAST        'n2'

578	LOAD_FAST         'n'
581	LOAD_ATTR         'getChildren'
584	CALL_FUNCTION_0   None
587	LOAD_ATTR         'reparentTo'
590	LOAD_FAST         'n2'
593	CALL_FUNCTION_1   None
596	POP_TOP           None

597	LOAD_FAST         'n'
600	LOAD_ATTR         'removeNode'
603	CALL_FUNCTION_0   None
606	POP_TOP           None
607	JUMP_BACK         '545'
610	POP_BLOCK         None
611_0	COME_FROM         '538'

611	LOAD_FAST         'bldgGroup'
614	LOAD_ATTR         'flattenStrong'
617	CALL_FUNCTION_0   None
620	POP_TOP           None

621	LOAD_FAST         'bldgGroup'
624	LOAD_ATTR         'getNode'
627	LOAD_CONST        0
630	CALL_FUNCTION_1   None
633	LOAD_ATTR         'getBounds'
636	CALL_FUNCTION_0   None
639	LOAD_ATTR         'isEmpty'
642	CALL_FUNCTION_0   None
645	POP_JUMP_IF_TRUE  '671'

648	LOAD_FAST         'self'
651	LOAD_ATTR         'buildingGroups'
654	LOAD_FAST         'side'
657	BINARY_SUBSCR     None
658	LOAD_ATTR         'append'
661	LOAD_FAST         'bldgGroup'
664	CALL_FUNCTION_1   None
667	POP_TOP           None
668	JUMP_FORWARD      '671'
671_0	COME_FROM         '668'

671	LOAD_FAST         'i'
674	LOAD_CONST        1
677	INPLACE_ADD       None
678	STORE_FAST        'i'
681	JUMP_BACK         '471'
684	POP_BLOCK         None
685_0	COME_FROM         '468'

685	LOAD_FAST         'i'
688	LOAD_FAST         'maxNum'
691	COMPARE_OP        '>'
694	POP_JUMP_IF_FALSE '417'

697	LOAD_FAST         'i'
700	STORE_FAST        'maxNum'
703	JUMP_BACK         '417'
706	JUMP_BACK         '417'
709	POP_BLOCK         None
710_0	COME_FROM         '404'

710	SETUP_LOOP        '982'
713	LOAD_CONST        'innersidest'
716	LOAD_CONST        'outersidest'
719	BUILD_LIST_2      None
722	GET_ITER          None
723	FOR_ITER          '981'
726	STORE_FAST        'side'

729	BUILD_LIST_0      None
732	LOAD_FAST         'self'
735	LOAD_ATTR         'buildingGroups'
738	LOAD_FAST         'side'
741	STORE_SUBSCR      None

742	LOAD_CONST        None
745	LOAD_FAST         'self'
748	LOAD_ATTR         'currBldgInd'
751	LOAD_FAST         'side'
754	STORE_SUBSCR      None

755	LOAD_CONST        None
758	LOAD_FAST         'self'
761	LOAD_ATTR         'currBldgGroups'
764	LOAD_FAST         'side'
767	STORE_SUBSCR      None

768	SETUP_LOOP        '978'
771	LOAD_GLOBAL       'xrange'
774	LOAD_FAST         'maxNum'
777	CALL_FUNCTION_1   None
780	GET_ITER          None
781	FOR_ITER          '977'
784	STORE_FAST        'i'

787	SETUP_LOOP        '974'
790	LOAD_CONST        ('innerbarricade', 'outerbarricade')
793	GET_ITER          None
794	FOR_ITER          '973'
797	STORE_FAST        'barricade'

800	LOAD_FAST         'self'
803	LOAD_ATTR         'townGeom'
806	LOAD_ATTR         'find'
809	LOAD_CONST        '**/Buildings_'
812	LOAD_FAST         'side'
815	BINARY_ADD        None
816	LOAD_CONST        '-'
819	BINARY_ADD        None
820	LOAD_FAST         'barricade'
823	BINARY_ADD        None
824	LOAD_CONST        '_'
827	BINARY_ADD        None
828	LOAD_GLOBAL       'str'
831	LOAD_FAST         'i'
834	CALL_FUNCTION_1   None
837	BINARY_ADD        None
838	CALL_FUNCTION_1   None
841	STORE_FAST        'bldgGroup'

844	LOAD_FAST         'bldgGroup'
847	LOAD_ATTR         'isEmpty'
850	CALL_FUNCTION_0   None
853	POP_JUMP_IF_FALSE '862'

856	CONTINUE          '794'
859	JUMP_FORWARD      '862'
862_0	COME_FROM         '859'

862	LOAD_FAST         'bldgGroup'
865	LOAD_ATTR         'findAllMatches'
868	LOAD_CONST        '**/+ModelNode'
871	CALL_FUNCTION_1   None
874	STORE_FAST        'l'

877	SETUP_LOOP        '950'
880	LOAD_FAST         'l'
883	GET_ITER          None
884	FOR_ITER          '949'
887	STORE_FAST        'n'

890	LOAD_FAST         'n'
893	LOAD_ATTR         'getParent'
896	CALL_FUNCTION_0   None
899	LOAD_ATTR         'attachNewNode'
902	LOAD_FAST         'n'
905	LOAD_ATTR         'getName'
908	CALL_FUNCTION_0   None
911	CALL_FUNCTION_1   None
914	STORE_FAST        'n2'

917	LOAD_FAST         'n'
920	LOAD_ATTR         'getChildren'
923	CALL_FUNCTION_0   None
926	LOAD_ATTR         'reparentTo'
929	LOAD_FAST         'n2'
932	CALL_FUNCTION_1   None
935	POP_TOP           None

936	LOAD_FAST         'n'
939	LOAD_ATTR         'removeNode'
942	CALL_FUNCTION_0   None
945	POP_TOP           None
946	JUMP_BACK         '884'
949	POP_BLOCK         None
950_0	COME_FROM         '877'

950	LOAD_FAST         'self'
953	LOAD_ATTR         'buildingGroups'
956	LOAD_FAST         'side'
959	BINARY_SUBSCR     None
960	LOAD_ATTR         'append'
963	LOAD_FAST         'bldgGroup'
966	CALL_FUNCTION_1   None
969	POP_TOP           None
970	JUMP_BACK         '794'
973	POP_BLOCK         None
974_0	COME_FROM         '787'
974	JUMP_BACK         '781'
977	POP_BLOCK         None
978_0	COME_FROM         '768'
978	JUMP_BACK         '723'
981	POP_BLOCK         None
982_0	COME_FROM         '710'

982	LOAD_FAST         'self'
985	LOAD_ATTR         'townGeom'
988	LOAD_ATTR         'findAllMatches'
991	LOAD_CONST        '**/prop_tree_*'
994	CALL_FUNCTION_1   None
997	STORE_FAST        'treeNodes'

1000	SETUP_LOOP        '1027'
1003	LOAD_FAST         'treeNodes'
1006	GET_ITER          None
1007	FOR_ITER          '1026'
1010	STORE_FAST        'tree'

1013	LOAD_FAST         'tree'
1016	LOAD_ATTR         'flattenStrong'
1019	CALL_FUNCTION_0   None
1022	POP_TOP           None
1023	JUMP_BACK         '1007'
1026	POP_BLOCK         None
1027_0	COME_FROM         '1000'

1027	LOAD_FAST         'self'
1030	LOAD_ATTR         'townGeom'
1033	LOAD_ATTR         'findAllMatches'
1036	LOAD_CONST        '**/prop_snow_tree_*'
1039	CALL_FUNCTION_1   None
1042	STORE_FAST        'snowTreeNodes'

1045	SETUP_LOOP        '1072'
1048	LOAD_FAST         'snowTreeNodes'
1051	GET_ITER          None
1052	FOR_ITER          '1071'
1055	STORE_FAST        'snowTree'

1058	LOAD_FAST         'snowTree'
1061	LOAD_ATTR         'flattenStrong'
1064	CALL_FUNCTION_0   None
1067	POP_TOP           None
1068	JUMP_BACK         '1052'
1071	POP_BLOCK         None
1072_0	COME_FROM         '1045'

1072	SETUP_LOOP        '1135'
1075	LOAD_CONST        'inner'
1078	LOAD_CONST        'outer'
1081	LOAD_CONST        'innersidest'
1084	LOAD_CONST        'outersidest'
1087	BUILD_LIST_4      None
1090	GET_ITER          None
1091	FOR_ITER          '1134'
1094	STORE_FAST        'side'

1097	SETUP_LOOP        '1131'
1100	LOAD_FAST         'self'
1103	LOAD_ATTR         'buildingGroups'
1106	LOAD_FAST         'side'
1109	BINARY_SUBSCR     None
1110	GET_ITER          None
1111	FOR_ITER          '1130'
1114	STORE_FAST        'grp'

1117	LOAD_FAST         'grp'
1120	LOAD_ATTR         'stash'
1123	CALL_FUNCTION_0   None
1126	POP_TOP           None
1127	JUMP_BACK         '1111'
1130	POP_BLOCK         None
1131_0	COME_FROM         '1097'
1131	JUMP_BACK         '1091'
1134	POP_BLOCK         None
1135_0	COME_FROM         '1072'

1135	LOAD_FAST         'self'
1138	LOAD_ATTR         'showBuildings'
1141	LOAD_CONST        0
1144	CALL_FUNCTION_1   None
1147	POP_TOP           None
1148	LOAD_CONST        None
1151	RETURN_VALUE      None

Syntax error at or near `POP_BLOCK' token at offset 684

    def unloadUrbanTrack(self):
        del self.buildingGroups
        self.townGeom.removeNode()

    def loadFog(self):
        self.hasFog = True
        if self.isUrbanTrack:
            base.camLens.setFar(650)
        else:
            base.camLens.setFar(650)
        self.dummyNode = render.attachNewNode('dummyNode')
        if base.wantFog:
            self.fog = Fog('TrackFog')
            self.fog.setColor(Vec4(0.6, 0.7, 0.8, 1.0))
            if self.isUrbanTrack:
                self.fog.setLinearRange(1000.0, 1450.0)
            else:
                self.fog.setLinearRange(1000.0, 1800.0)
            render.setFog(self.fog)
        self.sky.setScale(1.725)
        self.sky.reparentTo(self.dummyNode)

    def showBuildings(self, t, forceRecompute = False):
        firstTimeCalled = 0
        if self.curve:
            t = t / self.curve.getMaxT()
        else:
            firstTimeCalled = 1
        if self.reversed:
            t = 1.0 - t
        numGroupsShown = 5
        for side in ['inner', 'outer']:
            numBldgGroups = len(self.buildingGroups[side])
            bldgInd = int(t * numBldgGroups)
            bldgInd = bldgInd % numBldgGroups
            if self.trackId in (RaceGlobals.RT_Urban_2, RaceGlobals.RT_Urban_2_rev):
                oldBldgInd = int(self.oldT * numBldgGroups)
                newBldgInd = int(t * numBldgGroups)
                kartPoint = self.startPos
                kart = base.cr.doId2do.get(self.kartMap.get(localAvatar.doId, None), None)
                if kart:
                    kartPoint = self.localKart.getPos()
                if not self.currBldgInd[side]:
                    self.currBldgInd[side] = 0
                curInd = self.currBldgInd[side]
                myCurGroup = self.buildingGroups[side][curInd]
                prevGrp = (curInd - 1) % numBldgGroups
                myPrevGroup = self.buildingGroups[side][prevGrp]
                nextGrp = (curInd + 1) % numBldgGroups
                myNextGroup = self.buildingGroups[side][nextGrp]
                curVector = myCurGroup.getNode(0).getBounds().getCenter() - kartPoint
                curDistance = curVector.lengthSquared()
                prevVector = myPrevGroup.getNode(0).getBounds().getCenter() - kartPoint
                prevDistance = prevVector.lengthSquared()
                nextVector = myNextGroup.getNode(0).getBounds().getCenter() - kartPoint
                nextDistance = nextVector.lengthSquared()
                if curDistance <= prevDistance and curDistance <= nextDistance:
                    bldgInd = self.currBldgInd[side]
                elif prevDistance <= curDistance and prevDistance <= nextDistance:
                    bldgInd = prevGrp
                elif nextDistance <= curDistance and nextDistance <= prevDistance:
                    bldgInd = nextGrp
                else:
                    self.notify.warning('unhandled case!!!!')
                    bldgInd = self.currBldgInd[side]
            if bldgInd != self.currBldgInd[side]:
                currBldgGroups = self.currBldgGroups[side]
                if currBldgGroups:
                    for i in currBldgGroups:
                        self.buildingGroups[side][i].stash()

                prevGrp2 = (bldgInd - 2) % numBldgGroups
                prevGrp = (bldgInd - 1) % numBldgGroups
                currGrp = bldgInd % numBldgGroups
                nextGrp = (bldgInd + 1) % numBldgGroups
                nextGrp2 = (bldgInd + 2) % numBldgGroups
                self.currBldgGroups[side] = [prevGrp2,
                 prevGrp,
                 currGrp,
                 nextGrp,
                 nextGrp2]
                for i in self.currBldgGroups[side]:
                    self.buildingGroups[side][i].unstash()

                self.currBldgInd[side] = bldgInd

        if self.currBldgGroups['inner'] != self.currBldgGroups['outer']:
            pass
        if t != self.oldT:
            self.oldT = t
        if self.trackId in (RaceGlobals.RT_Urban_2, RaceGlobals.RT_Urban_2_rev):
            if self.reversed:
                t = 1.0 - t
            for side in ['innersidest', 'outersidest']:
                segmentInd = int(t * self.barricadeSegments)
                seglmentInd = segmentInd % self.barricadeSegments
                if segmentInd != self.currBldgInd[side] or forceRecompute:
                    currBldgGroups = self.currBldgGroups[side]
                    if currBldgGroups:
                        for i in currBldgGroups:
                            self.buildingGroups[side][i].stash()

                    self.currBldgGroups[side] = []
                    if side == 'innersidest':
                        dict = self.innerBarricadeDict
                    elif side == 'outersidest':
                        dict = self.outerBarricadeDict
                    if segmentInd in dict:
                        self.currBldgGroups[side] = dict[segmentInd]
                    for i in self.currBldgGroups[side]:
                        self.buildingGroups[side][i].unstash()

                    self.currBldgInd[side] = segmentInd

        return

    def setupGeom(self):
        trackFilepath = RaceGlobals.TrackDict[self.trackId][0]
        self.geom = loader.loadModel(trackFilepath)
        self.geom.reparentTo(render)
        if self.reversed:
            lapStartPos = self.geom.find('**/lap_start_rev').getPos()
        else:
            lapStartPos = self.geom.find('**/lap_start').getPos()
        self.startPos = lapStartPos
        lapMidPos = self.geom.find('**/lap_middle').getPos()
        self.startingPos = []
        posLocators = self.geom.findAllMatches('**/start_pos*')
        for i in xrange(posLocators.getNumPaths()):
            self.startingPos.append([posLocators[i].getPos(), posLocators[i].getHpr()])

        self.notify.debug('self.startingPos: %s' % self.startingPos)
        self.wrongWay = False
        self.laps = 0
        if self.isUrbanTrack:
            self.loadUrbanTrack()
        self.genArrows()
        if self.reversed:
            self.curve = self.geom.find('**/curve_reverse').node()
        else:
            self.curve = self.geom.find('**/curve_forward').node()
        for i in xrange(4000):
            self.curvePoints.append(Point3(0, 0, 0))
            self.curve.getPoint(i / 4000.0 * (self.curve.getMaxT() - 1e-11), self.curvePoints[-1])
            self.curveTs.append(i / 4000.0 * (self.curve.getMaxT() - 1e-11))

        if self.trackId in (RaceGlobals.RT_Urban_2, RaceGlobals.RT_Urban_2_rev):
            self.precomputeSideStreets()
        self.startT = self.getNearestT(lapStartPos)
        self.midT = self.getNearestT(lapMidPos)
        self.gags = []
        gagList = RaceGlobals.TrackDict[self.trackId][4]
        for i in xrange(len(gagList)):
            self.notify.debug('generating gag: %s' % i)
            self.gags.append(RaceGag(self, i, Vec3(*gagList[i]) + Vec3(0, 0, 3)))

    def precomputeSideStreets(self):
        farDist = base.camLens.getFar() + 300
        farDistSquared = farDist * farDist
        for i in xrange(int(self.barricadeSegments)):
            testPoint = Point3(0, 0, 0)
            self.curve.getPoint(i / self.barricadeSegments * (self.curve.getMaxT() - 1e-11), testPoint)
            for side in ('innersidest', 'outersidest'):
                for bldgGroupIndex in xrange(len(self.buildingGroups[side])):
                    bldgGroup = self.buildingGroups[side][bldgGroupIndex]
                    if not bldgGroup.getNode(0).getBounds().isEmpty():
                        bldgPoint = bldgGroup.getNode(0).getBounds().getCenter()
                        vector = testPoint - bldgPoint
                        if vector.lengthSquared() < farDistSquared:
                            if side == 'innersidest':
                                dict = self.innerBarricadeDict
                            elif side == 'outersidest':
                                dict = self.outerBarricadeDict
                            else:
                                self.notify.error('unhandled side')
                            if i in dict:
                                if bldgGroupIndex not in dict[i]:
                                    dict[i].append(bldgGroupIndex)
                            else:
                                dict[i] = [bldgGroupIndex]
                    for childIndex in (0,):
                        if childIndex >= bldgGroup.getNumChildren():
                            continue
                        childNodePath = bldgGroup.getChild(childIndex)
                        bldgPoint = childNodePath.node().getBounds().getCenter()
                        vector = testPoint - bldgPoint
                        if vector.lengthSquared() < farDistSquared:
                            if side == 'innersidest':
                                dict = self.innerBarricadeDict
                            elif side == 'outersidest':
                                dict = self.outerBarricadeDict
                            else:
                                self.notify.error('unhandled side')
                            if i in dict:
                                if bldgGroupIndex not in dict[i]:
                                    dict[i].append(bldgGroupIndex)
                            else:
                                dict[i] = [bldgGroupIndex]

        for side in ('innersidest', 'outersidest'):
            for bldgGroup in self.buildingGroups[side]:
                bldgGroup.flattenStrong()

        if self.isUrbanTrack:
            self.showBuildings(0, forceRecompute=True)

    def findSegmentStart(self):
        kart = base.cr.doId2do.get(self.kartMap.get(localAvatar.doId, None), None)
        minLength2 = 1000000
        minIndex = -1
        currPoint = Point3(0, 0, 0)
        kartPoint = self.localKart.getPos()
        for i in xrange(len(self.curvePoints)):
            currPoint = self.curvePoints[i]
            currLength2 = (kartPoint - currPoint).lengthSquared()
            if currLength2 < minLength2:
                minLength2 = currLength2
                minIndex = i

        currPoint = self.curvePoints[minIndex]
        if minIndex + 1 == len(self.curvePoints):
            nextPoint = self.curvePoints[0]
        else:
            nextPoint = self.curvePoints[minIndex + 1]
        if minIndex - 1 < 0:
            prevIndex = len(self.curvePoints) - 1
        else:
            prevIndex = minIndex - 1
        forwardSegment = nextPoint - currPoint
        if (kartPoint - currPoint).dot(forwardSegment) > 0:
            return minIndex
        else:
            return prevIndex
            return

    def getNearestT(self, pos):
        minLength2 = 1000000
        minIndex = -1
        currPoint = Point3(0, 0, 0)
        for i in xrange(len(self.curvePoints)):
            currPoint = self.curvePoints[i]
            currLength2 = (pos - currPoint).lengthSquared()
            if currLength2 < minLength2:
                minLength2 = currLength2
                minIndex = i

        currPoint = self.curvePoints[minIndex]
        if minIndex + 1 == len(self.curvePoints):
            nextPoint = self.curvePoints[0]
        else:
            nextPoint = self.curvePoints[minIndex + 1]
        if minIndex - 1 < 0:
            prevIndex = len(self.curvePoints) - 1
        else:
            prevIndex = minIndex - 1
        forwardSegment = nextPoint - currPoint
        if (pos - currPoint).dot(forwardSegment) > 0:
            pole = minIndex
        else:
            pole = prevIndex
        currPoint = self.curvePoints[pole]
        nextPole = (pole + 1) % len(self.curvePoints)
        nextPoint = self.curvePoints[nextPole]
        segment = nextPoint - currPoint
        segment.setZ(0)
        segLength2 = segment.lengthSquared()
        posVector = pos - currPoint
        posVector.setZ(0)
        project = segment * (segment.dot(posVector) / segLength2)
        percent = project.lengthSquared() / segLength2
        if nextPole < pole:
            t = self.curveTs[pole] * (1 - percent) + self.curve.getMaxT() * percent
        else:
            t = self.curveTs[pole] * (1 - percent) + self.curveTs[nextPole] * percent
        return t

    def hasGag(self, slot, type, index):
        if self.gags[slot].isActive():
            self.gags[slot].disableGag()

    def leaveRace(self):
        self.fsm.request('leave')

    def finishRace(self):
        self.sendUpdate('heresMyT', [localAvatar.doId,
         self.lapCount,
         self.currLapT,
         globalClockDelta.localToNetworkTime(globalClock.getFrameTime())])
        self.fsm.request('finished')

    def racerLeft(self, avId):
        if avId != localAvatar.doId:
            self.gui.racerLeft(avId, unexpected=False)

    def skyTrack(self, task):
        return SZUtil.cloudSkyTrack(task)

    def startSky(self):
        if self.hasFog:
            SZUtil.startCloudSky(self, parent=self.dummyNode, effects=CompassEffect.PRot)
        else:
            SZUtil.startCloudSky(self, parent=render)

    def stopSky(self):
        taskMgr.remove('skyTrack')

    def pickupGag(self, slot, index):
        self.canShoot = False
        standing = self.gui.racerDict[localAvatar.doId].place - 1
        self.currGag = RaceGlobals.GagFreq[standing][index]
        cycleTime = 2
        self.gui.waitingOnGag(cycleTime)
        taskMgr.doMethodLater(cycleTime, self.enableShoot, 'enableShoot')
        self.sendUpdate('hasGag', [slot, self.currGag, index])

    def shootGag(self):
        if self.canShoot:
            if self.currGag == 1:
                self.bananaSound.play()
                self.shootBanana()
            elif self.currGag == 2:
                self.d_requestThrow(0, 0, 0)
                self.localKart.startTurbo()
            elif self.currGag == 3:
                self.d_requestThrow(0, 0, 0)
            elif self.currGag == 4:
                self.bananaSound.play()
                self.shootPie()
            self.currGag = 0
            self.gui.updateGag(0)

    def enableShoot(self, t):
        self.canShoot = True
        if self.gui:
            self.gui.updateGag(self.currGag)

    def shootBanana(self):
        pos = self.localKart.getPos(render)
        banana = self.banana.copyTo(self.geom)
        banana.setPos(pos)
        self.thrownGags.append(banana)
        self.d_requestThrow(pos[0], pos[1], pos[2])

    def shootPie(self):
        pos = self.localKart.getPos(render)
        self.d_requestThrow(pos[0], pos[1], pos[2])

    def genArrows(self):
        base.arrows = []
        arrowId = 0
        for boost in RaceGlobals.TrackDict[self.trackId][5]:
            self.genArrow(boost[0], boost[1], arrowId)
            arrowId += 1

    def genArrow(self, pos, hpr, id):
        factory = CardMaker('factory')
        factory.setFrame(-0.5, 0.5, -0.5, 0.5)
        arrowNode = factory.generate()
        arrowRoot = NodePath('root')
        baseArrow = NodePath(arrowNode)
        baseArrow.setTransparency(1)
        baseArrow.setTexture(self.boostArrowTexture)
        baseArrow.reparentTo(arrowRoot)
        arrow2 = baseArrow.copyTo(baseArrow)
        arrow2.setPos(0, 0, 1)
        arrow3 = arrow2.copyTo(arrow2)
        arrowRoot.setPos(*pos)
        arrowRoot.setHpr(*hpr)
        baseArrow.setHpr(0, -90, 0)
        baseArrow.setScale(24)
        arrowRoot.reparentTo(self.geom)
        trigger = 'boostArrow' + str(id)
        cs = CollisionTube(Point3(0.6, -6, 0), Point3(0.6, 54, 0), 4.8)
        cs.setTangible(0)
        triggerEvent = 'imIn-' + trigger
        cn = CollisionNode(trigger)
        cn.addSolid(cs)
        cn.setIntoCollideMask(BitMask32(32768))
        cn.setFromCollideMask(BitMask32(32768))
        cnp = NodePath(cn)
        cnp.reparentTo(arrowRoot)
        self.accept(triggerEvent, self.hitBoostArrow)
        arrowVec = arrow2.getPos(self.geom) - baseArrow.getPos(self.geom)
        arrowVec.normalize()
        idStr = str(id)
        cnp.setTag('boostId', idStr)
        self.boostDir[idStr] = arrowVec
        base.arrows.append(arrowRoot)

    def hitBoostArrow(self, cevent):
        if not self.localKart:
            return
        else:
            into = cevent.getIntoNodePath()
            idStr = into.getTag('boostId')
            arrowVec = self.boostDir.get(idStr)
            if arrowVec == None:
                print 'Unknown boost arrow %s' % idStr
                return
            fvec = self.localKart.forward.getPos(self.geom) - self.localKart.getPos(self.geom)
            fvec.normalize()
            dotP = arrowVec.dot(fvec)
            if dotP > 0.7:
                self.localKart.startTurbo()
            return

    def fadeOutMusic(self):
        if self.musicTrack:
            self.musicTrack.finish()
        curVol = self.raceMusic.getVolume()
        interval = LerpFunctionInterval(self.raceMusic.setVolume, fromData=curVol, toData=0, duration=3)
        self.musicTrack = Sequence(interval)
        self.musicTrack.start()

    def changeMusicTempo(self, newPR):
        if self.musicTrack:
            self.musicTrack.finish()
        self.musicTrack = Sequence(LerpFunctionInterval(self.raceMusic.setPlayRate, fromData=self.raceMusic.getPlayRate(), toData=newPR, duration=3))
        self.musicTrack.start()

    def setRaceZone(self, zoneId, trackId):
        hoodId = self.cr.playGame.hood.hoodId
        self.doneBarrier('waitingForExit')
        self.sendUpdate('racerLeft', [localAvatar.doId])
        out = {'loader': 'racetrack',
         'where': 'racetrack',
         'hoodId': hoodId,
         'zoneId': zoneId,
         'trackId': trackId,
         'shardId': None,
         'reason': RaceGlobals.Exit_UserReq}
        base.cr.playGame.hood.loader.fsm.request('quietZone', [out])
        return


@magicWord(category=CATEGORY_PROGRAMMER, types=[str])
def race(command):
    command = command.lower()
    if command == 'leave':
        messenger.send('leaveRace')
        return 'You left the race!'
    if command == 'finish':
        messenger.send('finishRace')
        return 'You finished the race!'
    return 'Invalid command!'